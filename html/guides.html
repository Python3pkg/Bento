

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Guides &mdash; Bento vdev-nobuilt-gitdev-nobuil documentation</title>
    <link rel="stylesheet" href="static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     'dev-nobuilt-gitdev-nobuil',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="top" title="Bento vdev-nobuilt-gitdev-nobuil documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="index.html">Bento vdev-nobuilt-gitdev-nobuil documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Guides</a><ul>
<li><a class="reference internal" href="#metadata">Metadata</a></li>
<li><a class="reference internal" href="#customizable-installation-paths">Customizable installation paths</a><ul>
<li><a class="reference internal" href="#flexible-install-scheme">Flexible install scheme</a></li>
<li><a class="reference internal" href="#custom-data-paths">Custom data paths</a></li>
</ul>
</li>
<li><a class="reference internal" href="#retrieving-data-files-at-runtime">Retrieving data files at runtime</a><ul>
<li><a class="reference internal" href="#example">Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#recursive-package-description">Recursive package description</a><ul>
<li><a class="reference internal" href="#simple-example">Simple example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#hook-files">Hook files</a><ul>
<li><a class="reference internal" href="#simple-example-hello-world">Simple example: hello world</a></li>
<li><a class="reference internal" href="#command-hook-and-bento-context">Command hook and bento context</a></li>
<li><a class="reference internal" href="#hook-and-recursive-package-definitions">Hook and recursive package definitions</a></li>
<li><a class="reference internal" href="#hook-and-yaku-customizing-extensions-compilation">Hook and yaku: customizing extensions compilation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conditional-packaging">Conditional packaging</a></li>
<li><a class="reference internal" href="#adding-new-commands">Adding new commands</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/guides.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="guides">
<h1>Guides<a class="headerlink" href="#guides" title="Permalink to this headline">¶</a></h1>
<div class="section" id="metadata">
<h2>Metadata<a class="headerlink" href="#metadata" title="Permalink to this headline">¶</a></h2>
<p>Bento supports most metadata defined in the PEP 241 and 314:</p>
<div class="highlight-python"><pre>Name: foo
Version: 0.0.1
Summary: a few words
Description: you can
    use multiple lines here
Url: http://example.com
DownloadUrl: http://example.com
Author: John Doe
AuthorEmail: john@doe.com
Maintainer: John Doe
MaintainerEmail: john@doe.com
License: BSD
Platforms: darwin, win32
InstallRequires: foo
BuildRequires: bar</pre>
</div>
</div>
<div class="section" id="customizable-installation-paths">
<h2>Customizable installation paths<a class="headerlink" href="#customizable-installation-paths" title="Permalink to this headline">¶</a></h2>
<p>Most packages have some files besides pure code: configuration, data
files, documentation, etc... When those files need to be installed,
you should use DataFiles sections. Each such section has two mandatory
fields, to specify the target directory (where files are installed)
and which files are specific to this section:</p>
<div class="highlight-python"><pre>DataFiles: manage
    TargetDir: /usr/man/man1
    Files: fubar/fubar1</pre>
</div>
<p>This will install the file top_dir/fubar/fubar1 into
/usr/man/man1/fubar/fubar1.</p>
<div class="section" id="flexible-install-scheme">
<h3>Flexible install scheme<a class="headerlink" href="#flexible-install-scheme" title="Permalink to this headline">¶</a></h3>
<p>Hardcoding the target directory as above is not flexibe. The user may
want to install manpages somewhere else. Bento defines a set of
variable paths which are customizable, with platform-specific
defaults. For manpages, the variable is mandir:</p>
<div class="highlight-python"><pre>DataFiles: manpage
    TargetDir: $mandir/man1
    Files: fubar/fubar.1</pre>
</div>
<p>Now, the installation path is customizable, e.g.:</p>
<div class="highlight-python"><pre>bentomaker configure --mandir=/opt/man</pre>
</div>
<p>will cause the target directory to translate to /opt/man/man1.
Moreover, as mandir default value is defined relatively to $prefix ($prefix/man
on unix), modifying the prefix will also change how mandir is expanded at
install time:</p>
<div class="highlight-python"><pre># $mandir is automatically expanded to /opt/man
bentomaker configure --prefix=/opt</pre>
</div>
<p>If you do not want to install files with their directory component,
you need to use the SourceDir option:</p>
<div class="highlight-python"><pre>DataFiles: manpage
    TargetDir: $mandir
    SourceDir: fubar
    Files: fubar.1</pre>
</div>
<p>will install fubar/fubar.1 as $mandir/fubar.1 instead of
$mandir/fubar/fubar.1.</p>
</div>
<div class="section" id="custom-data-paths">
<h3>Custom data paths<a class="headerlink" href="#custom-data-paths" title="Permalink to this headline">¶</a></h3>
<p>TODO</p>
</div>
</div>
<div class="section" id="retrieving-data-files-at-runtime">
<h2>Retrieving data files at runtime<a class="headerlink" href="#retrieving-data-files-at-runtime" title="Permalink to this headline">¶</a></h2>
<p>It is often necessary to retrieve data files from your python code.  For
example, you may have a configuration file which needs to be read at startup.
The simplest way to do so is to use __file__ and refer to data files relatively
to python code location. This is not very flexible, because it requires dealing
with platform idiosyncraties w.r.t. file location.  Setuptools and its
descendents have an alternative mechanism to retrieve resources at runtime,
implemented in the pkg_resource module.</p>
<p>Bento uses a much simpler system, based on a simple python module generated at
install time, containing all the relevant information. This file is not
generated by default, and you need to define which file will contain all those
variables with the ConfigPy field:</p>
<div class="highlight-python"><pre>ConfigPy: foo/__bento_config.py</pre>
</div>
<p>This tells bento to generate a module, and install it into
foo/__bento_config.py. The path is always relative to site-packages (e.g.
/usr/local/lib/python2.6/site-packages/foo/__bento_config.py by default on
unix).  The file looks as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">DOCDIR</span> <span class="o">=</span> <span class="s">&quot;/usr/local/share/doc/config_py&quot;</span>
<span class="n">SHAREDSTATEDIR</span> <span class="o">=</span> <span class="s">&quot;/usr/local/com&quot;</span>
<span class="o">...</span>
</pre></div>
</div>
<p>to that you can import every path variable with its expanded value in your
package:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">foo.__bento_config</span> <span class="kn">import</span> <span class="n">DOCDIR</span><span class="p">,</span> <span class="n">SHAREDSTATEDIR</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c"># Default values (so that the package may be imported/used without</span>
    <span class="c"># being built)</span>
    <span class="n">DOCDIR</span> <span class="o">=</span> <span class="o">...</span>
</pre></div>
</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>Assuming the following bento file:</p>
<div class="highlight-python"><pre>...

DataFiles: test_data
    SourceDir: data
    TargetDir: $pkgdatadir
    Files:
        foo.dat

ConfigPy: foo/__bento_config.py</pre>
</div>
<p>you can access &#8220;foo.dat&#8221; as follows in your package:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">foo.__bento_config</span> <span class="kn">import</span> <span class="n">PKGDATADIR</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">PKGDATADIR</span> <span class="o">=</span> <span class="s">&quot;data&quot;</span> <span class="c"># default value</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">PKGDATADIR</span><span class="p">,</span> <span class="s">&quot;foo.dat&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="recursive-package-description">
<h2>Recursive package description<a class="headerlink" href="#recursive-package-description" title="Permalink to this headline">¶</a></h2>
<p>If you have a package with a lot of python subpackages which require
custom configurations, doing everything in one bento.info file is
restrictive. Bento has a simple recursive feature so that one
bento.info can refer to another bento.info:</p>
<div class="highlight-python"><pre>...
Recurse: foo, bar</pre>
</div>
<p>The Recurse field indicates to bento that it should look for bento.info in both
foo/ and bar/ directories. At this time, those bento.info files support a
strict subset of the top bento.info. For example, no metadata may be defined in
sub-bento.info.</p>
<div class="section" id="simple-example">
<h3>Simple example<a class="headerlink" href="#simple-example" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s assume that you have a software with the packages foo, foo.bar
and foo.foo. The simplest way to define this software would be:</p>
<div class="highlight-python"><pre>...
Library:
    Packages: foo, foo.bar, foo.fubar</pre>
</div>
<p>Alternatively, an equivalent description, using the recursive feature:</p>
<div class="highlight-python"><pre>...
Recurse: foo

Library:
    Package: foo</pre>
</div>
<p>and the foo/bento.info:</p>
<div class="highlight-python"><pre>...
Library:
    Packages: bar, fubar</pre>
</div>
<p>The packages are defined relatively to the directory where the subento file is
located. Obviously, in this case, it is overkill, but for complex, deeply
nested packages (like scipy or twisted), this makes the bento.info more
readable. It is especially useful when you use this with the hook file
mechanism, where each subento file can drive a part of the configure/build
through command hooks and overrides. In that case, the hook file defined in a
subdirectory only sees the libraries, modules, etc... defined in the
corresponding bento.info by default (see hook section).</p>
</div>
</div>
<div class="section" id="hook-files">
<h2>Hook files<a class="headerlink" href="#hook-files" title="Permalink to this headline">¶</a></h2>
<p><em>Note: the hook API is still in flux, and should not be relied on. It is
documented to give an idea of where bento is going, but I still reserve myself
the right to change things in fundamental ways.</em></p>
<p>Although many typical python softwares can be entirely described in bento.info,
complex packages may require a more advanced configuration, e.g.:</p>
<blockquote>
<ul class="simple">
<li>Conditionally define libraries depending on systems configuration
(addition features if you have the C library libfoo, etc...)</li>
<li>Define new bento commands</li>
<li>Customization of the build process (e.g. compiler flags, linked
libraries, etc...)</li>
<li>Add new tools in the build process (cython, source code generator,
etc...)</li>
<li>Use of a different build tool than the one included in bento (waf, scons
or even make).</li>
<li>add new options to an existing command</li>
</ul>
</blockquote>
<p>Instead of cramming too many features in the bento.info, bento allows you to
add one (or more) &#8220;hook&#8221; files, which are regular python modules, but under the
control of bento.</p>
<div class="section" id="simple-example-hello-world">
<h3>Simple example: hello world<a class="headerlink" href="#simple-example-hello-world" title="Permalink to this headline">¶</a></h3>
<p>The hello world for bento hook system is simple: it prints &#8220;yummy bento&#8221;
everytime you execute bentomaker. Assuming the following bento.info file:</p>
<div class="highlight-python"><pre>Name: foo
HookFile: bscript</pre>
</div>
<p>the hook file will look like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">startup</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&quot;Yummy bento&quot;</span>
</pre></div>
</div>
<p>As its name suggests, the startup method is executed before running any
command, and before bentomaker itself parses the command line. As such, you do
not want to do to many things there &#8211; typically register new commands.</p>
</div>
<div class="section" id="command-hook-and-bento-context">
<h3>Command hook and bento context<a class="headerlink" href="#command-hook-and-bento-context" title="Permalink to this headline">¶</a></h3>
<p>Each command (configure, build, install, etc...) in bento has a
pre_command_name hook, a post_command_hook, and an override hook. Just defining
hooks is not very useful, though - you need to be able to interact with bento
to do interesting things.</p>
<p>Each hook is a regular python function - its hook &#8220;status&#8221; is defined by the hook decorator(s):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bento.commands.hooks</span> <span class="kn">import</span> <span class="n">post_configure</span>

<span class="nd">@post_configure</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">pconfigure</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>The function takes one parameter, ctx. Its class does not matter much at this
point, but its members do. First, both the command instance (cmd) and the
command options (cmd_opts) are always available. The command instance
corresponds to the requested command (bentomaker configure -&gt;
bento.commands.configure.Configure class). cmd_opts is a simple list of the
command line arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bento.commands.hooks</span> <span class="kn">import</span> <span class="n">post_configure</span>

<span class="nd">@post_configure</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">pconfigure</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">ctx</span><span class="o">.</span><span class="n">cmd_opts</span>
</pre></div>
</div>
<p>Each ctx variable also has a pkg member, which is a
PackageDescription instance, and contains most package information.
Metadata, extensions, path options, executables are all available,
which enables the following:</p>
<blockquote>
<ul class="simple">
<li>access package information to generate new &#8220;targets&#8221; (new types
of binary installers)</li>
<li>add extra source files whose location cannot be known at
configure time</li>
<li>add/remove/modify extensions, packages dynamically</li>
</ul>
</blockquote>
<p>For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">bento.commands.hooks</span> <span class="kn">import</span> <span class="n">post_configure</span>

<span class="nd">@post_configure</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">pconfigure</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">ext_name</span> <span class="ow">in</span> <span class="n">pkg</span><span class="o">.</span><span class="n">extensions</span><span class="p">:</span>
        <span class="c"># List the sources of every extension</span>
        <span class="k">print</span> <span class="n">pkg</span><span class="o">.</span><span class="n">extensions</span><span class="p">[</span><span class="n">ext_name</span><span class="p">]</span><span class="o">.</span><span class="n">sources</span>
</pre></div>
</div>
<p>This may not look like much, but this ability to query extensions
inside your hook file makes integration with external build tools much
easier.</p>
<p><em>Note: unfortunately, there is still no public API for safe
PackageDescription instances access. Most read access should be safe,
but modifying package description members is likely to break in the
future</em></p>
</div>
<div class="section" id="hook-and-recursive-package-definitions">
<h3>Hook and recursive package definitions<a class="headerlink" href="#hook-and-recursive-package-definitions" title="Permalink to this headline">¶</a></h3>
<p>TODO</p>
</div>
<div class="section" id="hook-and-yaku-customizing-extensions-compilation">
<h3>Hook and yaku: customizing extensions compilation<a class="headerlink" href="#hook-and-yaku-customizing-extensions-compilation" title="Permalink to this headline">¶</a></h3>
<p><em>Note: this is almost guaranteed to change, I am still deeply
unsatisfied with the API. This should illustrate a few core features
of bento w.r.t. to building extension, though. IOW, the API will
change, but the features will stay</em></p>
<p>Customizing compilation of extensions is a significant pain point in
distutils. Bento includes by default a simple build tool, yaku. Bento
has a few API to make interaction with yaku easier, in particular for
compilation customization:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@pre_build</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">pbuild</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="n">env</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;CFLAGS&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s">&quot;-Os&quot;</span><span class="p">]}</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">register_environment</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
</pre></div>
</div>
<p>The register_environment will update the compilation environment for
the foo extension. Each extension can register a different environment
through this mechanism. Env can contain any key as used by yaku (that
includes the compiler, compiler flags, etc...), but note that new
flags are appended to existing values.</p>
<p>You can also register an entirely new builder for a given extension. This
requires dealing with yaku&#8217;s relatively low-level API, but it enables
basically any kind of transformation, like compiling each source
differently, associating new tools to existing source suffix, etc....
This is unfortunately the only way to override environments ATM:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@pre_build</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">pbuild</span><span class="p">(</span><span class="n">ctx</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">builder</span><span class="p">(</span><span class="n">bld</span><span class="p">,</span> <span class="n">extension</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
        <span class="c"># Environments are attached to builders, and cloning a</span>
        <span class="c"># builder attach a fresh copied dictionary</span>
        <span class="n">_blder</span> <span class="o">=</span> <span class="n">bld</span><span class="o">.</span><span class="n">builders</span><span class="p">[</span><span class="s">&quot;pyext&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="c"># Change in the blder.env will not affect any other</span>
        <span class="c"># extension</span>
        <span class="n">_blder</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="s">&quot;PYEXT_CC&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;clang&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_blder</span><span class="p">(</span><span class="n">extension</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">extension</span><span class="o">.</span><span class="n">sources</span><span class="p">)</span>
    <span class="n">ctx</span><span class="o">.</span><span class="n">register_builder</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span>
</pre></div>
</div>
<p>You should refer to yaku examples directory to get an idea of what&#8217;s
possible.</p>
</div>
</div>
<div class="section" id="conditional-packaging">
<h2>Conditional packaging<a class="headerlink" href="#conditional-packaging" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="adding-new-commands">
<h2>Adding new commands<a class="headerlink" href="#adding-new-commands" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="index.html">Bento vdev-nobuilt-gitdev-nobuil documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, David Cournapeau.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.3.
    </div>
  </body>
</html>