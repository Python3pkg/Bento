..  Wed Nov 11 01:06:58 JST 2009

What's needed for a first prototype
===================================

Basic requirements are listed here

Fully static package description
--------------------------------

We delegate everything related to build and install to distutils,
and we just use the config file as input instead of writing metadata in
setup.py. Goal: building hello world packages with C extensions with a 2 lines
setup.py and the package description entirely defined in the metadata.

Status
~~~~~~

This is mostly done. What's missing::

	.# Documentation tagging

Simple build system
-------------------

Based on a configure/build/install-like scheme::

        .# Should support all autoconf dir-related options (includedir, etc...)
        .# Think about extensibility from the start: pre/post hooks for each
           step, how to add steps maybe ?

Requires::

        .# Make flag and paths input/output consistent in cabal_parser, so that
           they can easily be used to describe options (to configure command
           mostly)
        .# Decide on internal representation of paths and possible stages of
           substitution to interdependencies between paths
        .# Decide of a format to dump/restore configure options

More advanced features
~~~~~~~~~~~~~~~~~~~~~~

Things which are necessary for realistically replace distutils/setuptools::

        .# building C/C++ extensions
        .# building wininst, msi
        .# no-install (develop) mode
        .# interoperation with pip-like tool ?

Goodies::

        .# Should support building sphinx doc
        .# Should support check-like step (build sdist, build from sdist, and
           test from sdist)
        .# Add scons builders for simple scons-based build

Build and Install requirements sections
---------------------------------------

Second step: build and install requirements. Once handled at
parsing/description level, we may build a small tool on top of say pip to
download all the necessasry packages - this would be a toy utility.

This requires::

        .# Version handling: see distutils and the new PEP 386.
        .# Parsing requirements in config file

Later
=====

Things to think about

Tools integration
-----------------

Example: paver-like tool integration, scons/waf integration

Distutils compatibility story
-----------------------------

Distutils compat: from config file to setup.py, from setup.py to config file

Distribution content description
--------------------------------

The current MANIFEST mechanism is insane, as is using the VCS to determine
files to include. But some people want it::

        .# How to support the following use-case: someones use the VCS to
        generate the sdist content, I want to reproduce it from the sdist only.
        .# Is a update_sdist command to update the content from the VCS
        acceptable ?
        .# Description needs to be rich enough so that following the FSH is
        possible

Export to 3rd party distribution tools
--------------------------------------

nsis, visual studio, deb, rpm, etc... What matters is how to plug-in new
exporters.

Install/Reinstall/Rebuild/Clean problem
---------------------------------------

Reliable builds
~~~~~~~~~~~~~~~

For complex packages, the solution is clearly make/scons/waf/etc....

For simple packages, one needs something simpler:
	
	- How hard would it be to have dependency handling in toydist ?
	- Do we need full dependency ? Since it would arguably used for simple
	  problems, brute force may be considered. For example, one could
	  always install, byte-compile everything from scratch, and only do
	  dependency handling for build

Reliable install/reinstall
~~~~~~~~~~~~~~~~~~~~~~~~~~

InstalledPkgInfo should be enough to install/uninstall things, so including it
in installers should be sufficient to get all the data, although it may not be
very efficient.

Fundamental problem: toydist vs native packages. Possible solutions:

	1 create a new local site-packages specific to toydist, and only use
	  toydist-enabled package for dependencies:

	  	- advantages: reliable, relatively simple
		- disadvantages: invasive, requires all dependencies to be
		  under toydist (in particular numpy/scipy/matplotlib)

	2 try to cope with existing, already installed packages.

	  	- advantages: no barrier of entry, gradual migration
		- disadvantages: how to do it ?

Documentation
=============

Things to think about:

	- Documenting the .info file
	- Formal Grammar

Scipi
=====

Pypi does not work for the scientific community, so we need to replate it with
our own stack. The goal is something like CRAN:

	- publish a package from sdist with a cabal-like file to scipi
	- the package would be automatically checked for metadata consistency,
	  built (included documentation)
	- if the package builds correctly, the package will be available on the
	  given platform(s)
	- scipi would have a simple web interface ala CRAN

Technical issues:

	- Simple server for published files (mirrored through rsync). Ideally,
	  pure http is enough
	- Simple WEB-API to get metadata + files
