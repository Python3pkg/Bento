#! /usr/bin/env python
import sys
import os
import getopt
import optparse

from toydist.utils import \
        subst_vars
from toydist.sysconfig import \
        get_scheme
from toydist.cabal_parser.cabal_parser import \
        parse

from toydist.commands.core import \
        Command, HelpCommand
from toydist.commands.configure import \
        ConfigureCommand
from toydist.commands.core import \
        register_command, UsageException, \
        MyOptionParser, get_command_names, get_command, \
        get_public_command_names

TOYMAKER_DEBUG = True
SCRIPT_NAME = 'toymaker'

class ToymakeException(Exception):
    pass

class BuildCommand(Command):
    long_descr = """\
Purpose: build the project
Usage:   toymaker build [OPTIONS]."""
    short_descr = "build the project."

class ParseCommand(Command):
    long_descr = """\
Purpose: query the given package description file (debugging tool)
Usage:   toymaker parse [OPTIONS]"""
    short_descr = "parse the package description file."
    opts = Command.opts + [
        {"opts": ["-f", "--flags"], "action": "store_true", "help": "print flags variables"},
        {"opts": ["-p", "--path"], "action": "store_true", "help": "print paths variables"}
    ]

    def run(self, opts):
        self.set_option_parser()
        o, a = self.parser.parse_args(opts)
        if o.help:
            self.parser.print_help()
            return

        if len(a) < 1:
            raise UsageException("%s: error: %s subcommand require an argument" \
                    % (SCRIPT_NAME, "parse"))
        else:
            filename = a[0]
        from toydist.cabal_parser.cabal_parser import parse

        f = open(filename, "r")
        try:
            data = f.readlines()
            parsed = parse(data, {}, {})
            if o.flags:
                try:
                    flags = parsed["flag_options"]
                    for flag in flags:
                        print flags[flag]
                except KeyError:
                    pass
            elif o.path:
                try:
                    paths = parsed["path_options"]
                    for path in paths:
                        print paths[path]
                except KeyError:
                    pass
            else:
                print parsed
        finally:
            f.close()

#================================
#   Create the command line UI
#================================
register_command("help", HelpCommand)
register_command("configure", ConfigureCommand)
register_command("build", BuildCommand)

register_command("parse", ParseCommand, public=False)
 
def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    show_usage = False
    cmd_name = None
    cmd_opts = None

    try:
        opts, pargs = getopt.getopt(argv, "h", ["help"])
        for opt, arg in opts:
            if opt in ("--help", "-h"):
                show_usage = True

        if len(pargs) > 0:
            cmd_name = pargs.pop(0)
            cmd_opts = pargs
    except getopt.GetoptError, e:
        emsg = "%s: illegal global option -- %s" % (SCRIPT_NAME, e.opt)
        print emsg
        print get_usage()
        return 1

    if show_usage:
        print get_usage()
        return 0

    if not cmd_name:
        print "Type '%s help' for usage." % SCRIPT_NAME
        return 1
    else:
        if not cmd_name in get_command_names():
            raise UsageException("%s: Error: unknown command %s" % (SCRIPT_NAME, cmd_name))
        else:
            cmd = get_command(cmd_name)()
            cmd.run(cmd_opts)

def noexc_main(argv=None):
    try:
        ret = main(argv)
    except UsageException, e:
        print e
        sys.exit(1)
    except Exception, e:
        if TOYMAKER_DEBUG:
            import traceback
            tb = sys.exc_info()[2]
            traceback.print_tb(tb)
        print "%s: Error: %s crashed (uncaught exception %s: %s)." % \
                (SCRIPT_NAME, SCRIPT_NAME, e.__class__, str(e))
        sys.exit(1)
    sys.exit(ret)

if __name__ == '__main__':
    noexc_main()
