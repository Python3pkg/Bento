import os
import sys
import subprocess
import shutil

import os.path as op

import bento

from bento._config \
    import \
        BENTO_SCRIPT, DISTCHECK_DIR
from bento.core.errors \
    import \
        BentoError
from bento.core.node_package \
    import \
        NodeRepresentation
from bento.commands.errors \
    import \
        CommandExecutionFailure
from bento.commands.core \
    import \
        Command, Option, COMMANDS_REGISTRY
from bento.commands.wrapper_utils \
    import \
        run_cmd_in_context
from bento.commands.context \
    import \
        CONTEXT_REGISTRY
from bento.core.utils \
    import \
        pprint, test_program_run
from bento.compat.api \
    import \
        rename, TarFile

from bento.commands import hooks

import yaku.context
import yaku.scheduler

@hooks.pre_configure
def pre_configure(ctx):
    try:
        ctx.yaku_context.load_tool("python_2to3")
    except ImportError:
        pass

PY3K_BUILD = os.path.join("build", "py3k")

_BENTOMAKER_SCRIPT = [op.join(op.dirname(bento.__file__), os.pardir, "bentomaker")]

#@hooks.command
def _run_2to3(ctx, njobs):
    bld = yaku.context.get_bld()
    if not "python_2to3" in bld.builders:
        raise ValueError("2to3 is not available")
    builder = bld.builders["python_2to3"]

    builder.env["2TO3_EXCLUDE_LIST"] = [
        os.path.join("bento", "private", "_ply", "ply", f) for f in \
        os.listdir(os.path.join("bento", "private", "_ply", "ply"))
        if f.endswith(".py")]

    node_pkg = NodeRepresentation(ctx.run_node, ctx.top_node)
    node_pkg.update_package(ctx.pkg)
    files = list(node_pkg.iter_files())
    builder.convert("bento_2to3", files)

    try:
        yaku.scheduler.run_tasks_parallel(bld, maxjobs=njobs)
    finally:
        bld.store()

@hooks.command
def run_2to3(ctx):
    """\
Purpose: run 2to3 on bento.
Usage: bentomaker run_2to3 [OPTIONS]"""
    p = ctx.options_context.parser
    o, a = p.parse_args(ctx.cmd_argv)

    njobs = o.njobs
    _run_2to3(ctx, njobs)

    msg = """\
===============================================================================
python 3 version of bento is now available in build/py3k. You can install bento
for python 3 as follows:

    cd %s
    python3 -m bentomakerlib.bentomaker configure # add custom options here
    python3 -m bentomakerlib.bentomaker install
===============================================================================\
""" % PY3K_BUILD
    pprint('BLUE', msg)

class TestPy3kCommand(Command):
    long_descr = """\
Purpose: test py3k output generated by 2to3
Usage:   bentomaker test_py3k [OPTIONS]."""
    short_descr = "check whether generated py3k code works."
    common_options = Command.common_options \
                        + [Option("-p", "--python-interpreter",
                                  help="python interpreter to use", dest="python_interpreter")]
    def run(self, ctx):
        argv = ctx.get_command_arguments()
        p = ctx.options_context.parser
        o, a = p.parse_args(argv)
        if o.help:
            p.print_help()
            return
        if o.python_interpreter:
            python_interpreter = o.python_interpreter
        else:
            python_interpreter = "python3"

        pprint("BLUE", "running distcheck on python 3 code...")
        p = subprocess.Popen([python_interpreter, "-m", "bentomakerlib.bentomaker", "distcheck"],
                             stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=PY3K_BUILD)
        stdout, stderr = p.communicate()
        print(try_decode(stdout))
        if p.returncode != 0:
            pprint('RED', "error while distchecking python 3 code: exception was")
            pprint('RED', "=" * 79)
            pprint('RED', try_decode(stderr))
            pprint('RED', "=" * 79)
            return p.returncode

def try_decode(s):
    try:
        return s.decode()
    except UnicodeError:
        return s

class TestCommand(Command):
    def run(self, ctx):
        pprint('BLUE', "Running test command....")

        if sys.platform == "win32":
            suffix = ".exe"
        else:
            suffix = ""
        p = ctx.options_context.parser
        o, a = p.parse_args(ctx.get_command_arguments())
        if sys.version_info[:2] < (2, 5):
            # XXX: would be good to understand why shell=True is necessary here
            cmd = [sys.executable, "-c", "'import nose; nose.core.main()'"]
            shell = True
            if not test_program_run(" ".join(cmd) + " -h", shell=shell):
                raise CommandExecutionFailure(
                        "nose not available for program %r - needed to test bento !" % cmd[0])
            cmd = " ".join(cmd)
        else:
            cmd = [sys.executable]
            if not test_program_run(cmd + ["-h"]):
                raise CommandExecutionFailure(
                        "program %r not found - needed to test bento !" % cmd[0])
            cmd.extend(["-m", "nose.core"])
            if not test_program_run(cmd + ["-h"]):
                raise CommandExecutionFailure(
                        "nose not available for program %r - needed to test bento !" % cmd[0])
            cmd.extend(["-s", "-v", "bento"])
            shell = False
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=shell)
        stdout, stderr = p.communicate()
        if p.returncode != 0:
            print(try_decode(stderr))
        else:
            for stream in [stdout, stderr]:
                print(try_decode(stream))

def run_sdist(context):
    sdist_name = "sdist"
    sdist_klass = COMMANDS_REGISTRY.get_command(sdist_name)
    cmd_argv = []
    sdist_context_klass = CONTEXT_REGISTRY.get(sdist_name)
    sdist, sdist_context = run_cmd_in_context(sdist_klass,
                        sdist_name, cmd_argv, sdist_context_klass,
                        context.run_node, context.top_node, context.pkg)
    return sdist

class DistCheckCommand(Command):
    long_descr = """\
Purpose: configure, build and test the project from sdist output
Usage:   bentomaker distcheck [OPTIONS]."""
    short_descr = "check that sdist output is buildable."
    def run(self, ctx):
        pprint('BLUE', "Distcheck...")
        pprint('PINK', "\t-> Running sdist...")

        sdist = run_sdist(ctx)
        archive_root, archive_node = sdist.archive_root, sdist.archive_node

        saved = os.getcwd()

        distcheck_dir = ctx.build_node.make_node(DISTCHECK_DIR)
        if os.path.exists(distcheck_dir.abspath()):
            shutil.rmtree(distcheck_dir.abspath())
        distcheck_dir.mkdir()
        target = distcheck_dir.make_node(archive_node.name)
        rename(archive_node.abspath(), target.abspath())
        archive_node = os.path.basename(target.abspath())

        os.chdir(distcheck_dir.abspath())
        try:
            pprint('PINK', "\t-> Extracting sdist...")
            tarball = TarFile.gzopen(archive_node)
            tarball.extractall()
            os.chdir(archive_root)

            def _call(cmd):
                p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                stdout, stderr = p.communicate()
                stdout = stdout.strip()
                stderr = stderr.strip()
                if stdout:
                    print stdout.decode()
                if stderr:
                    print stderr.decode()
                if p.returncode != 0:
                    raise CalledProcessError(p.returncode, cmd)

            if sys.version_info[0] < 3:
                bootstrap = os.path.join(os.getcwd(), "bootstrap.py")
                _call([sys.executable, bootstrap])
                bentomaker_script = _BENTOMAKER_SCRIPT
            else:
                bentomaker_script = [sys.executable, "-m", "bentomakerlib.bentomaker"]

            pprint('PINK', "\t-> Configuring from sdist...")
            _call(bentomaker_script + ["configure", "--prefix=%s" % os.path.abspath("tmp")])

            pprint('PINK', "\t-> Building from sdist...")
            _call(bentomaker_script + ["build", "-i"])

            pprint('PINK', "\t-> Building egg from sdist...")
            _call(bentomaker_script + ["build_egg"])

            if sys.platform == "win32":
                pprint('PINK', "\t-> Building wininst from sdist...")
                _call(bentomaker_script + ["build_wininst"])

            if "test" in COMMANDS_REGISTRY.get_command_names():
                pprint('PINK', "\t-> Testing from sdist...")
                try:
                    _call(bentomaker_script + ["test"])
                except CalledProcessError, e:
                    raise CommandExecutionFailure(
                            "test command failed")
            else:
                pprint('YELLOW', "\t-> No test command defined, no testing")
        finally:
            os.chdir(saved)

@hooks.startup
def startup(context):
    context.register_command("distcheck", DistCheckCommand)
    context.register_command("test", TestCommand)
    context.register_command("test_py3k", TestPy3kCommand)

    context.set_before("run_2to3", "configure")
    context.set_before("test_py3k", "run_2to3")

@hooks.options
def options(context):
    opt = Option("-j", help="Number of threads to use", dest="njobs", type="int", default=1)
    context.add_option("run_2to3", opt)
